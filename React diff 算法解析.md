###React Virtual DOM 原理浅析  
有人说：“I tend to think of React as Version Control for the DOM” 。闲话少说，下面来看React是怎么工作的~
	
####Diff 实现  
说道版本控制，就不得不提Diff, 对于diff大家很熟悉，对比新旧两个版本快照，从而生成一系列改动；而react 处理的DOM对象而不是文件。  
DOM是树形结构，所以diff算法必须是针对树形结构的。目前已知的完整树形结构diff算法复杂度为 O(n^3)   
假如页面中有 10000 个DOM节点，这个数字看起来很庞大，但是在页面也常见，如一个下拉列表加载1000条数据，。为了计算该复杂度的数量级大小，我们还假设在一个cpu主频为1GHz。这种情况下，diff要花费的时间如下：

	// 10000^3 = 1000 x 10^9
	//         ≈ 1000 seconds
	//         ≈ 17 minutes
	
整整有 17 分钟之长，简直无法想象！  
虽然验证阶段暂不考虑性能问题，但是我们可以简单了解一下算法[如何实现](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)。  
但实际思考一下，在web应用中，很少移动一个元素到另一个地方的场景。唯一的常用场景是在子元素之间移动元素，例如在列表中新增，删除和移动元素。那既然这样仅仅对比同层级的节点 

![Alt text](https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0MevjGWgyGWsTIXEdZcj3jxVZ4zPauMFpsLKhtSvV11sF3FcPbVsNgEE6wuqQJriasARA1blcFSpK8yIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1) 

如上图所示，仅对相同颜色的节点做diff，这样能把时间复杂度降到O(n^2).

##### key 属性的引入
针对同级元素的比较，又引入了另一个问题。  
  
同层级元素名称不同时，可以直接识别为不匹配；相同时，却没那么简单了。
看如下情况：  
![key](https://p3.ssl.qhimg.com/t01004c9585d327cfa5.jpg)  
首次渲染了三个input, 然后下一次渲染变成了两个，此时diff结果会如何呢？  
最直观的结果事前面两个保持不变，删除第三个。  
当然还有其他操作可以实现，这说明，对于相同标签名称的节点，我们没有足够的信息来对比前后的差异。
那给每个节点添加一个属性id来唯一标识呢？这样我们就可以很容易的识别出前后DOM的差异。这个属性最终确定为key，这也是为什么在react中使用列表时会要求给子元素设置可以属性的原因。  
结合 key，再加上哈希表，diff算法最终实现了 O(n)的最优复杂度。  

#### Virtual DOM  
react 引入了虚拟DOM的概念，初听虚拟DOM懵懵懂懂，下面来说一下为什么引入virtual DOM，以及什么是virtual DOM。  
前面说到， React 其实实现了对DOM 节点的版本控制  
做过js 应用优化的人可能都知道，DOM是复杂的，对它的操作（尤其是查询和创建）是非常慢且消耗资源的。看下面的例子，仅创建一个空白的div，实例属性就达到了231个。
	
	let m = 0;
	const div = document.createElment('div');
	
	for (let k in div) {
		m++;
	}
	console.log(m); // 231

之所以有那么多属性，是因为dom节点被用于浏览器渲染管道的很多过程中。  
浏览器首先根据css 规则查找匹配的节点，这个过程会缓存很多信息，例如它维护着一个对应DOM节点的id映射表。
然后根据样式计算几点布局，这里又会缓存位置和屏幕定位信息，浏览器会尽量避免重新极端布局，所以这些数据会被缓存。   
可以看出，整个渲染过程会消耗大量的内存和cpu 资源。  
现在回头想想react，它只是在diff算法中用到了DOM节点，而且只是用到了标签名称和部分属性。  
如果用更轻量级的js 对象来替代复杂的DOM节点，然后把对DOM的diff操作转移到js对象，就可以避免大量的DOM查询操作。这种方式成为VirtualDOM  
![分类位置图示](https://p2.ssl.qhimg.com/t0130ed7f3ca258cb09.jpg)

图中过程如下：  
1. 维护一个使用js对象表示的Virtual DOM, 与真实DOM 一一对应。  
2. 对前后两个virtual DOM 做diff，生成变成队列（Mutation）  
3. 把变成应用于真实DOM，生成最新的真实DOM.  

可以看出，因为要把变成应用到真实DOM上，所以还是避免不了直接操作dom，但是react 的diff算法会把dom的改动次数降到最低。

至此一个相对完美的react出世，faceBook 做了个重大的决定，那就是react开源。

接下来要说的两大优势就是来源于开源社区

#### 批处理（Batching）
我们说的DOM是很慢的，除了前面提到的他的复杂和庞大，还有另外一个原因就是重排和重绘。  
当DOM被修改后，浏览器必须更新元素的位置和真实像素；  
当尝试从DOM读取属性时，为了保证读取的值时正确的，浏览器也会触发重排和重绘。   

另外， 由于浏览器本身对DOM操作进行了优化，比如把两次很近的‘修改’ 操作合并成一个修改操作。  
所以把 读取 读取 修改 修改 重新排列为“读取、读取、修改、修改”，会有助于减小重排和重绘的次数。这是这种是刻意的、动手的级联写法是不安全的。  
与此同时，常规的js写法又很容易触发重排和重绘。  

在react中，开发者通过调用setState 方法告诉React当前组件要变更了。 
![](https://p2.ssl.qhimg.com/t01591daee426eaa7fa.jpg)
调用setState 时不立即变更同步到Virtual DOM, 而是仅仅把对应元素打上 待更新 的标记。 如果组件内调用多次setState，那么都会进行相同的打标操作。  
等到初始化事件被完全广播开以后，就开始进行从顶部到底部的重新渲染过程。这就确保了React只对元素进行一次操作。  
这里需要注意两点  
1. 此处重新渲染是只，setState 更新到virtual DOM ，然后进行diff，把变更更新到真正的DOM。  
2. 与前文提到的“重新渲染整个 DOM ”不同的是，真实的重新渲染仅渲染被标记的元素及其子元素，也就是说上图中仅蓝色圆圈代表的元素会被重新渲染  

这提醒开发者，应该让拥有状态的组件尽量靠近叶子节点，这样可以缩小重新渲染的范围。  


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

